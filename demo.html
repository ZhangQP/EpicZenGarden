<!DOCTYPE html>
<html lang="en">
<head>
	<title>EpicZenGarden</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<script>
		// Configuration item: enable this hosting an asm.js fallback, and set to false if hosting only Wasm version.
		const supportsAsmJsAsFallback = false;

		// Minimum WebGL version that the page needs in order to run. UE4 will attempt to use WebGL 2 if available.
		// Set this to 1 to run with a WebGL 1 fallback if the graphical features required by your UE4 project are
		// low enough that they do not strictly require WebGL 2.
		const requiredWebGLVersion = 1;

		var runningAsmJs = (location.search.indexOf('asmjs') != -1);
		if (!runningAsmJs && typeof WebAssembly === 'undefined') {
			// Load the asm.js version if wasm is not supported.
			runningAsmJs = supportsAsmJsAsFallback;
		}
		if (runningAsmJs) console.log('Running asm.js fallback');

		// By default, Shipping builds serve out compressed assets, and Development builds serve uncompressed assets.
		// Change the following line to customize. When hosting UE4 builds live on a production CDN, compression
		// should always be enabled, since uncompressed files are too huge to be downloaded over the web.
		const serveCompressedAssets = true;

		// For the large .data file, there's two ways to manage compression: either UE4 UnrealPak tool can compress it in engine, or
		// it can be gzip compressed on disk like other assets. Compressing via UnrealPak has the advantage of storing a smaller data
		// file to IndexedDB, whereas gzip compressing to disk has the advantage of starting up the page slightly faster.
		// If true, serve out 'UE4Game.data.gz', if false, serve out 'UE4Game.data'.
		const dataFileIsGzipCompressed = true;

		var Module = {
			key: 'zengarden-wasm',
			injectXMLHttpRequests: false,
			providesRafIntegration: true,
			usesEmscriptenHTML5InputAPI: true,
			overrideNumFramesToRender: 3200,
			noRefTest: true,
			// state management
			infoPrinted: false,
			lastcurrentDownloadedSize: 0,
			totalDependencies: 0,
			dataBytesStoredInIndexedDB: 0, // Track how much data is currently stored in IndexedDB.

			assetDownloadProgress: {}, // Track how many bytes of each needed asset has been downloaded so far.

			UE4_indexedDBName: 'UE4_assetDatabase_ZenGarden',
			UE4_indexedDBVersion: 11, // Bump this number to invalidate existing IDB storages in browsers.

			preRun: [function() { addRunDependency('wait-for-compiled-code'); }]
		};

		// Tests if type === 'browser' or type === 'os' is 64-bit or not.
		function heuristicIs64Bit(type) {
			function contains(str, substrList) { for(var i in substrList) if (str.indexOf(substrList[i]) != -1) return true; return false; }
			var ua = (navigator.userAgent + ' ' + navigator.oscpu + ' ' + navigator.platform).toLowerCase();
			if (contains(ua, ['wow64'])) return type === 'os'; // 32bit browser on 64bit OS
			if (contains(ua, ['x86_64', 'amd64', 'ia64', 'win64', 'x64', 'arm64', 'irix64', 'mips64', 'ppc64', 'sparc64'])) return true;
			if (contains(ua, ['i386', 'i486', 'i586', 'i686', 'x86', 'arm7', 'android', 'mobile', 'win32'])) return false;
			if (contains(ua, ['intel mac os'])) return true;
			return false;
		}

		// For best stability on 32-bit browsers, allocate asm.js/WebAssembly heap up front before proceeding
		// to load any other page content. This mitigates the chances that loading up page assets first would
		// fragment the memory area of the browser process.
		var supportsWasm = (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function');
		if (runningAsmJs) supportsWasm = false; // Pretend that Wasm doesn't exist if explicitly asked to run asm.js version.
		var pageSize = supportsWasm ? 64 * 1024 : 16 * 1024 * 1024;
		var heuristic64BitBrowser = heuristicIs64Bit('browser');
		function alignPageUp(size) { return pageSize * Math.ceil(size / pageSize); }

		// The application should not be able to allocate more than MAX bytes of memory. If the application
		// attempts to allocate any more, it will be forbidden. Use this field to defensively impose a
		// strict limit to an application to keep it from going rogue with its memory usage beyond some
		// undesired limit. The absolute maximum that is possible is one memory page short of 2GB.
		var MAX_MEMORY_64BIT = Infinity;
		var MAX_MEMORY_32BIT = Infinity;
		var MAX_MEMORY = Math.min(alignPageUp(heuristic64BitBrowser ? MAX_MEMORY_64BIT : MAX_MEMORY_32BIT), 2048 * 1024 * 1024 - pageSize);

		// The application needs at least this much memory to run. If the browser can't provide this,
		// the page startup should be aborted in an out-of-memory exception.
		var MIN_MEMORY = Math.min(alignPageUp(32 * 1024 * 1024), MAX_MEMORY);

		// As a hint to the implementation, the application would prefer to reserve this much address
		// space at startup, and the browser will attempt its best to satisfy this. If this is not
		// possible, the browser will attempt to allocate anything as close to this IDEAL amount as
		// possible, but at least MIN bytes.
		var IDEAL_MEMORY_64BIT = 192*1024*1024;
		var IDEAL_MEMORY_32BIT = 192*1024*1024;
		var IDEAL_MEMORY = Math.min(Math.max(alignPageUp(heuristic64BitBrowser ? IDEAL_MEMORY_64BIT : IDEAL_MEMORY_32BIT), MIN_MEMORY), MAX_MEMORY);

		// If true, assume the application will have most of its memory allocation pressure inside the
		// application heap, so reserve address space there up front. If false, assume that the memory
		// allocation pressure is outside the heap, so avoid reserving memory up front, until needed.
		var RESERVE_MAX_64BIT = false;
		var RESERVE_MAX_32BIT = false;
		var RESERVE_MAX = heuristic64BitBrowser ? RESERVE_MAX_64BIT : RESERVE_MAX_32BIT;

		// Try to get as much memory close to IDEAL, but at least MIN. For asm.js, start by reserving
		// MAX if requested to do so.
		for(var mem = (RESERVE_MAX && !supportsWasm) ? MAX_MEMORY : IDEAL_MEMORY; mem >= MIN_MEMORY; mem -= pageSize) {
			try {
				if (supportsWasm) {
					if (RESERVE_MAX) Module['wasmMemory'] = new WebAssembly.Memory({ initial: mem / pageSize, maximum: mem / pageSize });
					else Module['wasmMemory'] = new WebAssembly.Memory({ initial: mem / pageSize });
					Module['buffer'] = Module['wasmMemory'].buffer;
				} else {
					Module['buffer'] = new ArrayBuffer(mem);
				}
				if (Module['buffer'].byteLength != mem) throw 'Out of memory';
				break;
			} catch(e) { /*nop*/ }
		}
		if (!Module['buffer'] || !(Module['buffer'].byteLength >= MIN_MEMORY)) throw 'Out of memory';
		Module['TOTAL_MEMORY'] = Module['buffer'].byteLength;
		Module['MAX_MEMORY'] = MAX_MEMORY;
		function MB(x) { return (x/1024/1024) + 'MB'; }
		console.log('Initial memory size: ' + MB(Module['TOTAL_MEMORY']) + ' (MIN_MEMORY: ' + MB(MIN_MEMORY) + ', IDEAL_MEMORY: ' + MB(IDEAL_MEMORY) + ', MAX_MEMORY: ' + MB(MAX_MEMORY) + ', RESERVE_MAX: ' + RESERVE_MAX + ', heuristic64BitBrowser: ' + heuristic64BitBrowser + ', heuristic64BitOS: ' + heuristicIs64Bit('os') + ')');
	</script>
	<script src='../emtimer.js'></script>
	<script src="jquery-2.1.3.min.js"></script>
	<script src="bootstrap.min.js"></script>
	<link href="bootstrap.min.css" rel="stylesheet">
</head>
<body>

<style type="text/css">

body {
	background: url('background.png');
	background-repeat: no-repeat;
	background-size: 100%;
}

html, body, .container {
	height: 100%;
	font-family: "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
}

.h4, h4 {
	margin-top: 1pt;
	margin-bottom: 1pt;
	font-size: 10pt;
}

.container {
	display: table;
	vertical-align: middle;
	border: 0px;
	border-spacing: 0px;
}

.glyphicon-spin {
	animation: spin 2000ms infinite linear;
}

@keyframes spin {
	0% {
		transform: rotate(0deg);
	}
	100% {
		transform: rotate(359deg);
	}
}

@-webkit-keyframes spin {
	0% {
		transform: rotate(0deg);
	}
	100% {
		transform: rotate(359deg);
	}
}

.wrapper {
	position: relative;
	margin: 1em auto 10px auto;
	text-align: center;
	min-width: 640px;
	width: 100%;
	height: 480px; /* initial height, will be dynamically adjusted at runtime */
	max-width: 95%;
	display: block;
	align-items: center;
	position: relative;
	text-align: center;
	justify-content: center;
}

 .emscripten {
	padding-right: 0;
	margin-left: auto;
	margin-right: auto;
	display: block;
	display: -webkit-box;
	display: -moz-box;
	display: box;

	-webkit-box-align: center;
	-moz-box-align: center;
	box-align: center;

	-webkit-box-pack: center;
	-moz-box-pack: center;
	box-pack: center;
}

#canvas:not([fullscreen]) {
	padding-right: 0;
	margin-left: auto;
	margin-right: auto;
	width: 100%;
}

.texthalf {
	height: 37%;
	border: 0px;
	padding: 0px;
	overflow-y: scroll;
	font-size: 2em;
}

.buttonarea {
	min-height: 3%;
	border-top: 0px;
	border-bottom: 0px;
	padding: 0px;
	margin-right: 0px;
	margin-top: 0px;
	margin-bottom: 0px;
 }

.btn { padding: 0px; text-align: center; min-width: 150px }
.progress { background: rgba(245, 245, 245, 1); border: 0px solid rgba(245, 245, 245, 1); border-radius: 0px; height: 4px; }
.progress-bar-custom { background: rgba(153, 153, 153, 1); }
.centered-axis-xy {
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%,-50%);
}
/*#progressbar { width: 50%; margin: 0 auto; }*/

</style>

<script src='../cpuprofiler.js'></script>
<script src='inputstream.js'></script>

<div class="wrapper" id="mainarea">
	<div class="alert alert-warning centered-axis-xy" style="min-height: 20px; display:none;" role="alert" id="compilingmessage">
		<div id='loadTasks'> </div>
	</div>
	<canvas id="canvas" class="emscripten" oncontextmenu="event.preventDefault()" style="display:none;">
</div>
<div class="row buttonarea text-center" id="buttonrow">
	<div class="col-sm-2 text-center"></div>
	<!--
	<div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" onclick="Module['pauseMainLoop']();">Pause</button></div>
	<div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" onclick="Module['resumeMainLoop']();">Resume</button></div> -->
	<div class="col-sm-2 text-center"></div>
	<div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" id='clear_indexeddb' style='display:none;' onclick="deleteIndexedDBStorage(); $.jStorage.flush()">Clear IndexedDB</button></div>
	<div class="col-sm-2 text-center"><button type="button" class="btn btn-primary" id="fullscreen_request" style='display:none;'>FullScreen</button></div>
	<div class="col-sm-2 text-center"></div>
	<div class="col-sm-2 text-center"></div>
</div>
<div class="texthalf text-normal jumbotron " id="logwindow" style='display:none'></div>

<script type="text/javascript">

// EMTIMER:
if (!performance.realNow) performance.realNow = function() { return performance.now(); }

// combine all parallel downloads into one progress bar.
var totalDownloadSize = 0;
var currentDownloadedSize = 0;

// helper functions.
// http://stackoverflow.com/questions/4750015/regular-expression-to-find-urls-within-a-string
function getHTMLGetParam(name) {
	if (name=(new RegExp('[?&]'+encodeURIComponent(name)+'=([^&]*)')).exec(location.search))
		return decodeURIComponent(name[1]);
}

var UE4 = {
	on_fatal: function() {
		try {
			UE4.on_fatal = Module.cwrap('on_fatal', null, ['string', 'string']);
		} catch(e) {
			UE4.on_fatal = function() {};
		}
	},
};

Module['preinitializedWebGLContext'] = null;

function getGpuInfo() {
	var gl = Module['preinitializedWebGLContext'];
	if (!gl) return '(no GL: ' + Module['webGLErrorReason'] + ')';

	var glInfo = '';
	var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
	if (debugInfo) glInfo += gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) + ' ' + gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) + '/';
	glInfo += gl.getParameter(gl.VENDOR) + ' ' + gl.getParameter(gl.RENDERER);
	glInfo += ' ' + gl.getParameter(gl.VERSION);
	glInfo += ', ' + gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
	if (Module['softwareWebGL']) glInfo += ' (software)';
	return glInfo;
}

function detectWebGL() {
	var canvas = Module['canvas'] || document.createElement("canvas");
	// If you run into problems with WebGL 2, or for quick testing purposes, you can disable UE4
	// from using WebGL 2 and revert back to WebGL 1 by setting the following flag to true.
	var disableWebGL2 = false;
	var names = ["webgl", "experimental-webgl"];
	if (disableWebGL2) {
		WebGL2RenderingContext = undefined;
	} else {
		names = ["webgl2"].concat(names);
	}
	function testError(e) { Module['webGLErrorReason'] = e.statusMessage; };
	canvas.addEventListener("webglcontextcreationerror", testError, false);
	try {
		for(var failIfMajorPerformanceCaveat = 1; failIfMajorPerformanceCaveat >= 0; --failIfMajorPerformanceCaveat) {
			for(var i in names) {
				try {
					var context = canvas.getContext(names[i], {antialias:false,alpha:false,depth:true,stencil:true,failIfMajorPerformanceCaveat:!!failIfMajorPerformanceCaveat});
					Module['preinitializedWebGLContext'] = context;
					Module['softwareWebGL'] = !failIfMajorPerformanceCaveat;
					if (context && typeof context.getParameter == "function") return (names[i] == 'webgl2' ? 2 : 1);
				} catch(e) { Module['webGLErrorReason'] = e.toString(); }
			}
		}
	} finally {
		canvas.removeEventListener("webglcontextcreationerror", testError, false);
	}
	return 0;
}

Module['canvas'] = document.getElementById('canvas');

// Canvas scaling mode should be set to one of: 1=STRETCH, 2=ASPECT, or 3=FIXED.
// This dictates how the canvas size changes when the browser window is resized
// by dragging from the corner.
var canvasWindowedScaleMode = 2 /*ASPECT*/;

// In emunittest suite, need to render to predictable resolution, so in playback mode, render to FIXED 1366x768.
if (location.search.indexOf('playback') != -1 || location.search.indexOf('record') != -1) canvasWindowedScaleMode = 3 /*FIXED*/;

// High DPI setting configures whether to match the canvas size 1:1 with
// the physical pixels on the screen.
// For background, see https://www.khronos.org/webgl/wiki/HandlingHighDPI
var canvasWindowedUseHighDpi = true;

// Stores the initial size of the canvas in physical pixel units.
// If canvasWindowedScaleMode == 3 (FIXED), this size defines the fixed resolution
//                                          that the app will render to.
// If canvasWindowedScaleMode == 2 (ASPECT), this size defines only the aspect ratio
//                                           that the canvas will be constrained to.
// If canvasWindowedScaleMode == 1 (STRETCH), these size values are ignored.
var canvasAspectRatioWidth = 1366;
var canvasAspectRatioHeight = 768;

// Fullscreen scaling mode behavior (export these to Module object for the engine to read)
// This value is one of:
// 0=NONE: The same canvas size is kept when entering fullscreen without change.
// 1=STRETCH: The canvas is resized to the size of the whole screen, potentially changing aspect ratio.
// 2=ASPECT: The canvas is resized to the size of the whole screen, but retaining current aspect ratio.
// 3=FIXED: The canvas is centered on screen with a fixed resolution.
Module['UE4_fullscreenScaleMode'] = canvasWindowedScaleMode;

// When entering fullscreen mode, should UE4 engine resize the canvas?
// 0=No resizing (do it manually in resizeCanvas()), 1=Resize to standard DPI, 2=Resize to highDPI
Module['UE4_fullscreenCanvasResizeMode'] = canvasWindowedUseHighDpi ? 2/*HIDPI*/ : 1/*Standard DPI*/;

// Specifies how canvas is scaled to fullscreen, if not rendering in 1:1 pixel perfect mode.
// One of 0=Default, 1=Nearest, 2=Bilinear
Module['UE4_fullscreenFilteringMode'] = 0;

document.addEventListener('error', function(){document.getElementById('clear_indexeddb').style.display = 'inline-block';}, false);

// Startup task which is run after UE4 engine has launched.
function postRunEmscripten() {
	taskFinished(TASK_MAIN);
	$("#compilingmessage").remove();

	// The default Emscripten provided canvas resizing behavior is not needed,
	// since we are controlling the canvas sizes here, so stub those functions out.
	Browser.updateCanvasDimensions = function() {};
	Browser.setCanvasSize = function() {};

	// If you'd like to configure the initial canvas size to render using the resolution
	// defined in UE4 DefaultEngine.ini [SystemSettings] r.setRes=WidthxHeight,
	// uncomment the following two lines before calling resizeCanvas() below:

	// canvasAspectRatioWidth = UE_JSlib.UE_GSystemResolution_ResX();
	// canvasAspectRatioHeight = UE_JSlib.UE_GSystemResolution_ResY();

	// Configure the size of the canvas and display it.
	resizeCanvas();
	Module['canvas'].style.display = 'block';

	// Whenever the browser window size changes, relayout the canvas size on the page.
	window.addEventListener('resize', resizeCanvas, false);
	window.addEventListener('orientationchange', resizeCanvas, false);

	// The following is needed if game is within an iframe - main window already has focus...
	window.focus();

	// Start music
	if (!Module['disableAudio']) {
		document.getElementById('background-music').play();
	}

	if (location.search.indexOf('playback') == -1 && location.search.indexOf('record') == -1) {
		document.getElementById('fullscreen_request').style.display = 'inline-block';
		document.getElementById('clear_indexeddb').style.display = 'inline-block';
	}
}
Module.postRun = [postRunEmscripten];

/*
// HOTFIX: When exiting fullscreen, WebGL render target is not properly resized back to the old size.
// (this fix will be unnecessary in the future, as the engine itself is aware to resize back)
document.addEventListener("fullscreenchange", function(event) {
	UE_JSlib.UE_CanvasSizeChanged();
});
*/

// The resizeCanvas() function recomputes the canvas size on the page as the user changes
// the browser window size.
function resizeCanvas(aboutToEnterFullscreen) {
	// Configuration variables, feel free to play around with these to tweak.
	var minimumCanvasHeightCssPixels = 480; // the visible size of the canvas should always be at least this high (in CSS pixels)
	var minimumCanvasHeightFractionOfBrowserWindowHeight = 0.65; // and also vertically take up this much % of the total browser client area height.

	if (aboutToEnterFullscreen) { // UE4 engine is calling this function right before entering fullscreen?
		// If you want to perform specific resolution setup here, do so by setting Module['canvas'].width x Module['canvas'].height now,
		// and configure Module['UE4_fullscreenXXX'] fields above. Most of the time, the defaults are good, so no need to resize here.
		// Return true here if you want to abort entering fullscreen mode altogether.
		return;
	}

	// The browser called resizeCanvas() to notify that we just entered fullscreen? In that case, we never react, since the strategy is
	// to always set the canvas size right before entering fullscreen.
	if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
		return;
	}

	var mainArea = document.getElementById('mainarea');
	var canvasRect = mainArea.getBoundingClientRect();

	// Compute the unconstrained size for the div that encloses the canvas, in CSS pixel units.
	var cssWidth = canvasRect.right - canvasRect.left;
	var cssHeight = Math.max(minimumCanvasHeightCssPixels, canvasRect.bottom - canvasRect.top, window.innerHeight * minimumCanvasHeightFractionOfBrowserWindowHeight);

	if (canvasWindowedScaleMode == 3/*NONE*/) {
		// In fixed display mode, render to a statically determined WebGL render target size.
		var newRenderTargetWidth = canvasAspectRatioWidth;
		var newRenderTargetHeight = canvasAspectRatioHeight;
	} else {
		// Convert unconstrained render target size from CSS to physical pixel units.
		var newRenderTargetWidth = canvasWindowedUseHighDpi ? (cssWidth * window.devicePixelRatio) : cssWidth;
		var newRenderTargetHeight = canvasWindowedUseHighDpi ? (cssHeight * window.devicePixelRatio) : cssHeight;

		// Apply aspect ratio constraints, if desired.
		if (canvasWindowedScaleMode == 2/*ASPECT*/) {
			if (cssWidth * canvasAspectRatioHeight > canvasAspectRatioWidth * cssHeight) {
				newRenderTargetWidth = newRenderTargetHeight * canvasAspectRatioWidth / canvasAspectRatioHeight;
			} else {
				newRenderTargetHeight = newRenderTargetWidth * canvasAspectRatioHeight / canvasAspectRatioWidth;
			}
		}

		// WebGL render target sizes are always full integer pixels in size, so rounding is critical for CSS size computations below.
		newRenderTargetWidth = Math.round(newRenderTargetWidth);
		newRenderTargetHeight = Math.round(newRenderTargetHeight);
	}

	// Very subtle but important behavior is that the size of a DOM element on a web page in CSS pixel units can be a fraction, e.g. on
	// high DPI scaling displays (CSS pixel units are "virtual" pixels). If the CSS size and physical pixel size of the WebGL canvas do
	// not correspond to each other 1:1 after window.devicePixelRatio scaling has been applied, the result can look blurry. Therefore always
	// first compute the WebGL render target size first in physical pixels, and convert that back to CSS pixels so that the CSS pixel size
	// will perfectly align up and the result look clear without scaling applied.
	cssWidth = canvasWindowedUseHighDpi ? (newRenderTargetWidth / window.devicePixelRatio) : newRenderTargetWidth;
	cssHeight = canvasWindowedUseHighDpi ? (newRenderTargetHeight / window.devicePixelRatio) : newRenderTargetHeight;

	Module['canvas'].width = newRenderTargetWidth;
	Module['canvas'].height = newRenderTargetHeight;

	Module['canvas'].style.width = cssWidth + 'px';
	Module['canvas'].style.height = mainArea.style.height = cssHeight + 'px';

	// Tell the engine that the web page has changed the size of the WebGL render target on the canvas (Module['canvas'].width/height).
	// This will update the GL viewport and propagate the change throughout the engine.
	// If the CSS style size is changed, this function doesn't need to be called.
	if (UE_JSlib.UE_CanvasSizeChanged) UE_JSlib.UE_CanvasSizeChanged();
}
Module['UE4_resizeCanvas'] = resizeCanvas;

Module.arguments = ['../../../EpicZenGarden/EpicZenGarden.uproject ',''];

// we are serving via a server and it is unreal file server?
if (location.host != "" && getHTMLGetParam("cookonthefly") == "true") {
	Module.arguments.push("' -filehostIp=" + location.protocol + "//" + location.host + " '");
}

function addLog(info, color) {
	$("#logwindow").append("<h4><small>" + info + " </small></h4>");
}
Module.print = addLog;

Module.printErr = function(text) {
	console.error(text);
};

// Module.locateFile() routes asset downloads to either gzip compressed or uncompressed assets.
Module.locateFile = function(name) {
	var serveGzipped = serveCompressedAssets;
	// When serving from file:// URLs, don't read .gz compressed files, because these files can't be transparently uncompressed.
	var isFileProtocol = name.indexOf('file://') != -1 || location.protocol.indexOf('file') != -1;
	if (isFileProtocol) {
		if (!Module['shownFileProtocolWarning']) {
			showWarningRibbon('Attempting to load the page via the "file://" protocol. This only works in Firefox, and even there only when not using compression, so attempting to load uncompressed assets. Please host the page on a web server and visit it via a "http://" URL.');
			Module['shownFileProtocolWarning'] = true;
		}
		serveGzipped = false;
	}

	// Asset packages do not benefit from gzip compression because they are already compressed at UE4 packaging time,
	// and uncompressing very large gzip files would just slow down startup times.
	if (!dataFileIsGzipCompressed && name.split('.').slice(-1)[0] == 'data') serveGzipped = false;

	return serveGzipped ? (name + '.gz') : name;
};

// create a deferred object for the data file.
var dataFileDeferredObject = new $.Deferred();

// packaged data download, sets this information.
Module.setStatus = function(text) {
	var matches = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);

	if (matches == null) {
		addLog(text);
		return;
	}

	if (!this.infoPrinted) {
		for(var download in this.dataFileDownloads) {
			addLog(" starting download " + download + " [Packaged data]");
			// add to total size.
			totalDownloadSize += parseInt(matches[4]);
		}
		this.infoPrinted = true;
	}

	currentDownloadedSize += (parseInt(matches[2]) - this.lastcurrentDownloadedSize);
	this.lastcurrentDownloadedSize = parseInt(matches[2]);

	var percentage = currentDownloadedSize/totalDownloadSize * 100;
	$('.progress-bar-custom').css('width', percentage+'%').attr('aria-valuenow', percentage);

	if (matches[2] == matches[4]) {
		// lets resolve our deffered object
		dataFileDeferredObject.resolve("Data file download finished");

		for(var download in this.dataFileDownloads) {
			addLog(download + " downloaded ")
		}
	}
};

Module.monitorRunDependencies = function(left) {
	this.totalDependencies = Math.max(this.totalDependencies, left);
}

// Asynchronously appends the given script code to DOM. This is to ensure that
// browsers parse and compile the JS code parallel to all other execution.
function addScriptToDom(scriptCode) {
	return new Promise(function(resolve, reject) {
		var script = document.createElement('script');
		var blob = (scriptCode instanceof Blob) ? scriptCode : new Blob([scriptCode], { type: 'text/javascript' });
		var objectUrl = URL.createObjectURL(blob);
		script.src = objectUrl;
		script.onload = function() {
			script.onload = script.onerror = null; // Remove these onload and onerror handlers, because these capture the inputs to the Promise and the input function, which would leak a lot of memory!
			URL.revokeObjectURL(objectUrl); // Free up the blob. Note that for debugging purposes, this can be useful to comment out to be able to read the sources in debugger.
			resolve();
		}
		script.onerror = function(e) {
			script.onload = script.onerror = null; // Remove these onload and onerror handlers, because these capture the inputs to the Promise and the input function, which would leak a lot of memory!
			URL.revokeObjectURL(objectUrl);
			console.error('script failed to add to dom: ' + e);
			console.error(scriptCode);
			console.error(e);
			// The onerror event sends a DOM Level 3 event error object, which does not seem to have any kind of human readable error reason (https://developer.mozilla.org/en-US/docs/Web/Events/error)
			// There is another error event object at https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent, which would have an error reason. Perhaps that error event might sometimes be fired,
			// but if not, guess that the error reason was an OOM, since we are dealing with large .js files.
			reject(e.message || "(out of memory?)");
		}
		document.body.appendChild(script);
	});
}

var TASK_DOWNLOADING = 0;
var TASK_COMPILING = 1;
var TASK_SHADERS = 2;
var TASK_MAIN = 3;
var loadTasks = [ 'Downloading', runningAsmJs ? 'Compiling asm.js' : 'Compiling WebAssembly', 'Building shaders', 'Launching engine'];

function taskProgress(taskId, progress) {
	var c = document.getElementById('compilingmessage');
	if (c) c.style.display = 'block';
	else return;
	var l = document.getElementById('load_' + taskId);
	if (!l) {
		var tasks = document.getElementById('loadTasks');
		if (!tasks) return;
		l = document.createElement('div');
		l.innerHTML = '<span id="icon_' + taskId + '" class="glyphicon glyphicon-refresh glyphicon-spin"></span>  <span id="load_' + taskId + '"></span>';
		tasks.appendChild(l);
		l = document.getElementById('load_' + taskId);
	}
	if (!l.startTime) l.startTime = performance.realNow();
	var text = loadTasks[taskId];
	if (progress && progress.total) {
		text += ': ' + (progress.currentShow || progress.current) + '/' + (progress.totalShow || progress.total) + ' (' + (progress.current * 100 / progress.total).toFixed(0) + '%)';
	} else {
		text += '...';
	}
	l.innerHTML = text;
}

function showErrorDialog(errorText) {
	console.error('error: ' + errorText);
	var existingErrorDialog = document.getElementById('errorDialog');
	if (existingErrorDialog) {
		existingErrorDialog.innerHTML += '<br>' + errorText;
	} else {
		$('#mainarea').empty();
		$('#mainarea').append('<div class="alert alert-danger centered-axis-xy" style ="min-height: 10pt" role="alert" id="errorDialog">' + errorText + '</div></div>');
	}
}

function showWarningRibbon(warningText) {
	var existingWarningDialog = document.getElementById('warningDialog');
	if (existingWarningDialog) {
		existingWarningDialog.innerHTML += '<br>' + warningText;
	} else {
		$('#buttonrow').prepend('<div class="alert alert-warning centered-axis-x" role="warning" id="warningDialog" style="padding-top:5px; padding-bottom: 5px">' + warningText + '</div></div>');
	}
}

function taskFinished(taskId, error) {
	var l = document.getElementById('load_' + taskId);
	var icon = document.getElementById('icon_' + taskId);
	if (l && icon) {
		var totalTime = performance.realNow() - l.startTime;
		if (taskId == TASK_MAIN) {
			if (typeof emunittestReportCustomBlockDuration !== 'undefined') emunittestReportCustomBlockDuration('main()', totalTime);
		}
		if (!error) {
			l.innerHTML = loadTasks[taskId] + ' (' + (totalTime/1000).toFixed(2) + 's)';
			icon.className = 'glyphicon glyphicon-ok';
		}
		else {
			l.innerHTML = loadTasks[taskId] + ': FAILED! ' + error;
			icon.className = 'glyphicon glyphicon-remove';

			showErrorDialog(loadTasks[taskId] + ' failed: <br> ' + error);
		}
	}
}

window.onerror = function(e) {
	showErrorDialog(e.toString());
}

function formatBytes(bytes) {
	if (bytes >= 1024*1024*1024) return (bytes / (1024*1024*1024)).toFixed(1) + ' GB';
	if (bytes >= 1024*1024) return (bytes / (1024*1024)).toFixed(0) + ' MB';
	if (bytes >= 1024) return (bytes / 1024).toFixed(1) + ' KB';
	return bytes + ' B';
}

function reportDataBytesStoredInIndexedDB(deltaBytes) {
	if (deltaBytes === null) Module['dataBytesStoredInIndexedDB'] = 0; // call with deltaBytes == null to report that DB was cleared.
	else Module['dataBytesStoredInIndexedDB'] += deltaBytes;
	document.getElementById('clear_indexeddb').innerText = 'Clear IndexedDB (' + formatBytes(Module['dataBytesStoredInIndexedDB']) + ')';
}

function reportDownloadProgress(url, downloadedBytes, totalBytes, finished) {
	Module['assetDownloadProgress'][url] = {
		current: downloadedBytes,
		total: totalBytes,
		finished: finished
	};
	var aggregated = {
		current: 0,
		total: 0,
		finished: true
	};
	for(var i in Module['assetDownloadProgress']) {
		aggregated.current += Module['assetDownloadProgress'][i].current;
		aggregated.total += Module['assetDownloadProgress'][i].total;
		aggregated.finished = aggregated.finished && Module['assetDownloadProgress'][i].finished;
	}

	aggregated.currentShow = formatBytes(aggregated.current);
	aggregated.totalShow = formatBytes(aggregated.total);

	if (aggregated.finished) taskFinished(TASK_DOWNLOADING);
	else taskProgress(TASK_DOWNLOADING, aggregated);
}

function download(url, responseType) {
	return new Promise(function(resolve, reject) {
		var t0 = performance.realNow();
		var xhr = new XMLHttpRequest();
		xhr.open('GET', url, true);
		xhr.responseType = responseType || 'blob';
		reportDownloadProgress(url, 0, 1);
		xhr.onload = function() {
			var t1 = performance.realNow();
			if (typeof emunittestReportCustomBlockDuration !== 'undefined') emunittestReportCustomBlockDuration('XMLHttpRequests', '+' + (t1-t0));
			if (xhr.status == 0 || (xhr.status >= 200 && xhr.status < 300)) {
				var len = xhr.response.size || xhr.response.byteLength;
				reportDownloadProgress(url, len, len, true);
				resolve(xhr.response);
			} else {
				taskFinished(TASK_DOWNLOADING, 'HTTP error ' + (xhr.status || 404) + ' on file ' + url);
				reject({
					status: xhr.status,
					statusText: xhr.statusText
				});
			}
		};
		xhr.onprogress = function(p) {
			reportDownloadProgress(url, p.loaded, p.total);
		};
		xhr.onerror = function(e) {
			var isFileProtocol = url.indexOf('file://') == 0 || location.protocol.indexOf('file') != -1;
			if (isFileProtocol) taskFinished(TASK_DOWNLOADING, 'This page cannot be loaded using a "file://" URL.'); // Convert the most common source of errors to a more friendly message format.
			else taskFinished(TASK_DOWNLOADING, 'HTTP error ' + (xhr.status || 404) + ' on file ' + url);
			reject({
				status: xhr.status || 404,
				statusText: xhr.statusText
			});
		};
		xhr.onreadystatechange = function() {
			if (xhr.readyState >= xhr.HEADERS_RECEIVED && url.endsWith('gz') && xhr.getResponseHeader('Content-Encoding') != 'gzip') {
				// A fallback is to set serveCompressedAssets = false to serve uncompressed assets instead, but that is not really recommended for production use, since gzip compression shrinks
				// download sizes so dramatically that omitting it for production is not a good idea.
				taskFinished(TASK_DOWNLOADING, 'Downloaded a compressed file ' + url + ' without the necessary HTTP response header "Content-Encoding: gzip" specified!<br>Please configure gzip compression on this asset on the web server to serve gzipped assets!');
				xhr.onload = xhr.onprogress = xhr.onerror = xhr.onreadystatechange = null; // Abandon tracking events from this XHR further.
				xhr.abort();
				reject({
					status: 406,
					statusText: 'Not Acceptable'
				});
			}
		}
		xhr.send(null);
	});
}

Module['manualWasmInstantiate'] = function(info, receiveInstance) {
	Module['wasmDownloadAction'].then(function(downloadResults) {
		taskProgress(TASK_COMPILING);
		var t0 = performance.realNow();
		var wasmInstantiate = WebAssembly.instantiate(downloadResults.wasmModule || new Uint8Array(downloadResults.wasmBytes), info);
		return wasmInstantiate.then(function(output) {
			var instance = output.instance || output;
			var module = output.module;
			var t1 = performance.realNow();
			receiveInstance(instance);
			if (typeof emunittestReportCustomBlockDuration !== 'undefined') emunittestReportCustomBlockDuration('WebAssembly.instantiate()', (t1-t0));
			console.log('WebAssembly.instantiate(Module) took ' + (t1-t0) + 'msecs.');
			removeRunDependency("wasm-instantiate");
			taskFinished(TASK_COMPILING);
			Module['wasmInstantiateActionResolve'](instance);

			// After a successful instantiation, attempt to save the compiled Wasm Module object to IndexedDB.
			// if (!downloadResults.fromIndexedDB) {
			// 	storeToIndexedDB(downloadResults.db, 'wasmModule', module).catch(function() {
			// 		// If the browser did not support storing Wasm Modules to IndexedDB, try to store the Wasm instance instead.
			// 		return storeToIndexedDB(downloadResults.db, 'wasmBytes', downloadResults.wasmBytes);
			// 	});
			// }
			storeToPAB(PAB1, module).catch(function() {
				return storeToPAB(PAB1, downloadResults.wasmBytes);
			});
		});
	}).catch(function(error) {
		$ ('#mainarea').empty();
		$ ('#mainarea').append('<div class="alert alert-danger centered-axis-xy" style ="min-height: 10pt" role="alert">WebAssembly instantiation failed: <br> ' + error + '</div></div>');
	});
}

// Given a blob, asynchronously reads the byte contents of that blob to an arraybuffer and returns it as a Promise.
function readBlobToArrayBuffer(blob) {
	return new Promise(function(resolve, reject) {
		var fileReader = new FileReader();
		fileReader.onload = function() { resolve(this.result); }
		fileReader.onerror = function(e) { reject(e); }
		fileReader.readAsArrayBuffer(blob);
	});
}

function compileShadersFromJson(jsonData) {
	var shaderPrograms = [];
	if (jsonData instanceof ArrayBuffer) jsonData = new TextDecoder('utf-8').decode(new DataView(jsonData));
	var programsDict = JSON.parse(jsonData);
	for(var i in programsDict) {
		shaderPrograms.push(programsDict[i]);
	}

	var gl = Module['preinitializedWebGLContext'];

	Module['precompiledShaders'] = [];
	Module['precompiledPrograms'] = [];

	Module['glIDCounter'] = 1;
	Module['precompiledUniforms'] = [null];

	var t0 = performance.realNow();
	var promise = new Promise(function(resolve, reject) {
		var nextProgramToBuild = 0;
		function buildProgram() {
			if (nextProgramToBuild >= shaderPrograms.length) {
				var t1 = performance.realNow();
				if (typeof emunittestReportCustomBlockDuration !== 'undefined') emunittestReportCustomBlockDuration('shaderCompilation', (t1-t0));
				console.log('Building shaders took ' + (t1-t0) + ' msecs.');
				taskFinished(TASK_SHADERS);
				return resolve();
			}
			var p = shaderPrograms[nextProgramToBuild++];
			taskProgress(TASK_SHADERS, {current: nextProgramToBuild, total: shaderPrograms.length });
			var program = gl.createProgram();

			function lineNumberize(str) {
				str = str.split('\n');
				for(var i = 0; i < str.length; ++i) str[i] = (i<9?' ':'') + (i<99?' ':'') + (i+1) + ': ' + str[i];
				return str.join('\n');
			}

			var vs = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vs, p.vs);
			gl.compileShader(vs);
			var success = gl.getShaderParameter(vs, gl.COMPILE_STATUS);
			var compileLog = gl.getShaderInfoLog(vs);
			if (compileLog) compileLog = compileLog.trim();
			if (compileLog) console.error('Compiling vertex shader: ' + lineNumberize(p.vs));
			if (!success) console.error('Vertex shader compilation failed!');
			if (compileLog) console.error('Compilation log: ' + compileLog);
			if (!success) return reject('Vertex shader compilation failed: ' + compileLog);
			gl.attachShader(program, vs);

			Module['precompiledShaders'].push({
				vs: p.vs,
				shader: vs,
				program: program
			});

			var fs = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fs, p.fs);
			gl.compileShader(fs);
			var success = gl.getShaderParameter(fs, gl.COMPILE_STATUS);
			var compileLog = gl.getShaderInfoLog(fs);
			if (compileLog) compileLog = compileLog.trim();
			if (compileLog) console.error('Compiling fragment shader: ' + lineNumberize(p.fs));
			if (!success) console.error('Fragment shader compilation failed!');
			if (compileLog) console.error('Compilation log: ' + compileLog);
			if (!success) return reject('Fragment shader compilation failed: ' + compileLog);
			gl.attachShader(program, fs);

			Module['precompiledShaders'].push({
				fs: p.fs,
				shader: fs,
				program: program
			});

			for(var name in p.attribs) {
				gl.bindAttribLocation(program, p.attribs[name], name);
			}
			gl.linkProgram(program);
			var success = gl.getProgramParameter(program, gl.LINK_STATUS);
			var linkLog = gl.getProgramInfoLog(program);
			if (linkLog) linkLog = linkLog.trim();
			if (linkLog) console.error('Linking shader program, vs: \n' + lineNumberize(p.vs) + ', \n fs:\n' + lineNumberize(p.fs));
			if (!success) console.error('Shader program linking failed!');
			if (linkLog) console.error('Link log: ' + linkLog);
			if (!success) return reject('Shader linking failed: ' + linkLog);

			var ptable = {
				uniforms: {},
				maxUniformLength: 0,
				maxAttributeLength: -1,
				maxUniformBlockNameLength: -1
			};
			var GLctx = gl;
			var utable = ptable.uniforms;
				var numUniforms = GLctx.getProgramParameter(program, GLctx.ACTIVE_UNIFORMS);
				for (var i = 0; i < numUniforms; ++i) {
				var u = GLctx.getActiveUniform(program, i);
					var name = u.name;
					ptable.maxUniformLength = Math.max(ptable.maxUniformLength, name.length + 1);
					if (name.indexOf("]", name.length - 1) !== -1) {
					var ls = name.lastIndexOf("[");
					name = name.slice(0, ls);
					}
					var loc = GLctx.getUniformLocation(program, name);
					var id = Module['glIDCounter']++;
					utable[name] = [ u.size, id ];
					Module['precompiledUniforms'].push(loc);
					if (Module['precompiledUniforms'].length != Module['glIDCounter']) throw 'uniforms array not in sync! ' + Module['precompiledUniforms'].length + ', ' + Module['glIDCounter'];
					for (var j = 1; j < u.size; ++j) {
					var n = name + "[" + j + "]";
					loc = GLctx.getUniformLocation(program, n);
					id = Module['glIDCounter']++;
					Module['precompiledUniforms'].push(loc);
						if (Module['precompiledUniforms'].length != Module['glIDCounter']) throw 'uniforms array not in sync! ' + Module['precompiledUniforms'].length + ', ' + Module['glIDCounter'];
					}
				}

			var e = gl.getError();
			if (e) {
				console.error('Precompiling shaders got GL error: ' + e);
				return reject('Precompiling shaders got GL error: ' + e);
			}
		 	Module['precompiledPrograms'].push({
				program: program,
				programInfos: ptable,
				vs: p.vs,
				fs: p.fs
			});
				setTimeout(buildProgram, 0);
			}
		setTimeout(buildProgram, 0);
	})

	return promise;	
}

$(document).ready(function() {
	// check for webgl and cache it for later (UE_BrowserWebGLVersion() reads this)
	Module['WEBGL_VERSION'] = detectWebGL();
	console.log(getGpuInfo());
	if (!Module['WEBGL_VERSION'] || Module['WEBGL_VERSION'] < requiredWebGLVersion) {
		showErrorDialog('Your browser does not support WebGL ' + requiredWebGLVersion + '. Try updating your browser and/or graphics card drivers.<br>Current renderer: ' + getGpuInfo());
		return;
	}

	function shouldBrowserSupportWebGL2() {
		var match = window.navigator.userAgent.match(/Firefox\/([0-9]+)\./);
		if (match) return parseInt(match[1]) >= 51;
	}

	if (Module['WEBGL_VERSION'] < 2) {
		if (shouldBrowserSupportWebGL2()) {
			showWarningRibbon('Your browser does not support WebGL 2 because your browser version is too old. This affects graphics performance and quality. Please try updating your browser.<br>Current renderer: ' + getGpuInfo());
		} else {
			showWarningRibbon('Your browser does not support WebGL 2. This affects graphics performance and quality. Please try updating your browser version and graphics drivers if they are out of date.<br>Current renderer: ' + getGpuInfo());
		}
	}

	if (!heuristicIs64Bit('browser')) {
		if (heuristicIs64Bit('os')) {
			showWarningRibbon('It looks like you are running a 32-bit browser on a 64-bit operating system. This can dramatically affect performance. Try updating to <a href="https://www.mozilla.org/en-US/firefox/all/">64-bit Firefox</a> for an optimized experience.');
		} else {
			showWarningRibbon('It looks like your computer hardware is 32-bit. This can dramatically affect performance.');
		}
	}

	// The following WebGL 1.0 extensions are available in core WebGL 2.0 specification, so they are no longer shown in the extensions list.
	var webGLExtensionsInCoreWebGL2 = ['ANGLE_instanced_arrays','EXT_blend_minmax','EXT_color_buffer_half_float','EXT_frag_depth','EXT_sRGB','EXT_shader_texture_lod','OES_element_index_uint','OES_standard_derivatives','OES_texture_float','OES_texture_half_float','OES_texture_half_float_linear','OES_vertex_array_object','WEBGL_color_buffer_float','WEBGL_depth_texture','WEBGL_draw_buffers'];

	var supportedWebGLExtensions = Module['preinitializedWebGLContext'].getSupportedExtensions();
	if (Module['WEBGL_VERSION'] >= 2) supportedWebGLExtensions = supportedWebGLExtensions.concat(webGLExtensionsInCoreWebGL2);

	// The following WebGL extensions are required by UE4/this project, and it cannot run without.
	var requiredWebGLExtensions = []; // TODO: List WebGL extensions here that the demo needs and can't run without.
	for(var i in requiredWebGLExtensions) {
		if (supportedWebGLExtensions.indexOf(requiredWebGLExtensions[i]) == -1) {
			showErrorDialog('Your browser does not support WebGL extension ' + requiredWebGLExtensions[i] + ', which is required to run this page!');
		}
	}

	// The following WebGL extensions would be preferred to exist for best features/performance, but are not strictly needed and UE4 can fall back if not available.
	var preferredToHaveWebGLExtensions = [// The following are core in WebGL 2:
	                                      'ANGLE_instanced_arrays', // UE4 uses instanced rendering where possible, but can fallback to noninstanced. 
	                                      'EXT_color_buffer_half_float',
	                                      'EXT_sRGB',
	                                      'EXT_shader_texture_lod', // textureLod() is needed for correct reflections, without this reflection shaders are missing and render out black.
	                                      'OES_standard_derivatives',
	                                      'OES_texture_half_float',
	                                      'OES_texture_half_float_linear',
	                                      'OES_vertex_array_object',
	                                      'WEBGL_color_buffer_float',
	                                      'WEBGL_depth_texture',
	                                      'WEBGL_draw_buffers',

	                                      // These are still extensions in WebGL 2:
	                                      'OES_texture_float',
	                                      'WEBGL_compressed_texture_s3tc',
	                                      'EXT_texture_filter_anisotropic'
	];
	var unsupportedWebGLExtensions = [];
	for(var i in preferredToHaveWebGLExtensions) {
		if (supportedWebGLExtensions.indexOf(preferredToHaveWebGLExtensions[i]) == -1) {
			unsupportedWebGLExtensions.push(preferredToHaveWebGLExtensions[i]);
		}
	}
	if (unsupportedWebGLExtensions.length > 1) {
		showWarningRibbon('Your browser or graphics card does not support the following WebGL extensions: ' + unsupportedWebGLExtensions.join(', ') + '. This can impact UE4 graphics performance and quality.');
	} else if (unsupportedWebGLExtensions.length == 1) {
		showWarningRibbon('Your browser or graphics card does not support the WebGL extension ' + unsupportedWebGLExtensions[0] + '. This can impact UE4 graphics performance and quality.');
	}

	function noAsmJsFallbackHostedError() {
		if (location.search.indexOf('asmjs') != -1) showErrorDialog('There is no asm.js version deployed of this page.'); // Explicitly wanted to run asm.js version, but it did not exist.
		else showErrorDialog('Your browser does not support WebAssembly (and there is no asm.js fallback deployed of this page). Please try with Firefox 52 or newer.<br>Current user agent: ' + navigator.userAgent); // Automatically tried to fall back to asm.js since browser didn't have wasm, but no asm.js variant existed.
	}

	// No WebAssembly support?
	if ((!runningAsmJs || !supportsAsmJsAsFallback) && typeof WebAssembly === 'undefined') {
		showErrorDialog('Your browser does not support WebAssembly. Please try with Firefox 52 or newer.<br>Current user agent: ' + navigator.userAgent);
		return;
	}


	function withAB() {
		if (!runningAsmJs) {
			var mainCompiledCode = download(Module.locateFile('UE4Game-HTML5-Shipping.wasm'), 'arraybuffer');
			Module['wasmDownloadAction'] = mainCompiledCode;
			var compiledCodeInstantiateAction = new Promise(function(resolve, reject) {
				Module['wasmInstantiateActionResolve'] = resolve;
				Module['wasmInstantiateActionReject'] = reject;
			});
		}

		var BLOB1 = download(Module.locateFile('UE4Game-HTML5-Shipping.wasm'));
		var dataJsDownload = readBlobToArrayBuffer(BLOB1);

		var BLOB2 = download(Module.locateFile(runningAsmJs ? 'UE4Game-HTML5-Shipping_asm.js' : 'UE4Game-HTML5-Shipping.js'));
		var mainJsDownload = readBlobToArrayBuffer(BLOB2).then(addScriptToDom);

		var BLOB3 = download(Module.locateFile('Utility.js'));

		var dataArrayBuffer = download(Module.locateFile('EpicZenGarden.data'), 'arraybuffer');

		var downloads = [mainCompiledCode,
			readBlobToArrayBuffer(BLOB3).then(addScriptToDom),

// Instead as a fallback, download as ArrayBuffer. (TODO: Figure out the bugs with the above, and switch to using that one instead)
			function(dataArrayBuffer) {
				Module['preloadedPackages'] = {};
				Module['preloadedPackages'][Module.locateFile('EpicZenGarden.data')] = dataArrayBuffer;
				return dataJsDownload.then(addScriptToDom);
			}),

			mainJsDownload
		];

		// To enable/disable using precompiled shaders. Precompiled shaders are developed specific to WebGL 2, and don't work with WebGL 1.
		var precompileShaders = (Module['WEBGL_VERSION'] >= 2);

		if (precompileShaders) {
			var compileShaders = download(Module.locateFile('shaders.json'), 'arraybuffer')
			.then(function(json) {
				return compileShadersFromJson(json)
				.catch(function(error) {
					taskFinished(TASK_SHADERS, error + '<br>Current renderer: ' + getGpuInfo());
					throw 'Shader compilation failed';
				});
			});
		} else {
			var compileShaders = true;
		}

		downloads = downloads.concat([compiledCodeInstantiateAction,compileShaders]);
		Promise.all(downloads).then(function() {
			if (!precompileShaders) {
				Module['precompiledShaders'] = Module['precompiledPrograms'] = Module['preinitializedWebGLContext'] = Module['glIDCounter'] = Module['precompiledUniforms'] = null;
			}
			taskProgress(TASK_MAIN);
			setTimeout(function() {
				removeRunDependency('wait-for-compiled-code'); // Now we are ready to call main()
			}, 100);
		});		
	};

	// openIndexedDB(Module['UE4_indexedDBName'], Module['UE4_indexedDBVersion'] || 1).then(withIndexedDB).catch(function(e) {
	// 	console.error('Failed to openIndexedDB, proceeding without reading or storing contents to IndexedDB! Error: ');
	// 	console.error(e);
	// 	withIndexedDB(null);
	// });
	withAB();
});

</script>
<audio id='background-music' loop='true' src='ZenGarden.ogg' type='audio/ogg'></audio>
</body>
</html>
